# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iFSS9I1pAolhm-i7feRfp5w4enY3nh29
"""

import hashlib as hl
from pathlib import Path
from sortedcontainers import SortedDict
from datetime import datetime
import os
import pickle
import schedule
import time

#Cálculo del hash de un único fichero
def hashficherosha256(rutafichero):
  try:
    hash = hl.sha256()
    with open(rutafichero, "rb") as f: #rb: r - read, b - binary mode
      for bloque in iter(lambda: f.read(4096), b""): # Leemos el fichero en bloques de 4096 bytes
        hash.update(bloque)
    return hash.hexdigest()
  
  except Exception as e:
    print("Error: %s" % (e))
    return ""

#Cálculo del hash de todos los ficheros que se encuentran en el directorio especificado.
def listaficherossha256(dir, sortedDict):
  directorio = Path(dir)
  for fichero in directorio.iterdir():
    ubicacionfichero = dir + fichero.name
    if os.path.isdir(ubicacionfichero):
      listaficherossha256(ubicacionfichero+'/', sortedDict)
    else:
      if not sortedDict.__contains__(ubicacionfichero):
        sortedDict.update({ubicacionfichero: hashficherosha256(ubicacionfichero)})

#Serializa el objeto que contiene los hashes calculados.
def serializarDiccionarioHashes(archivo_pickle,diccionario):
  pickle_file = open(archivo_pickle, 'wb')
  pickle.dump(diccionario, pickle_file)

#Deserializa el objeto que contiene los hashes calculados de los ficheros, cuando se ejecuta el programa.
def deserializarDiccionarioHashes(archivo_pickle,diccionario):
  pickle_file = open(archivo_pickle, 'rb')
  diccionario = pickle.load(pickle_file)

#Busca el fichero que guarda los hashes, para cargarlos de nuevo. En caso de existir, lo cargará el existente, y se comprobará si existe algún
#fichero nuevo. Si no existe quiere decir que es la primera vez que se ejecuta el programa, por lo que habrá que calcular los hashes de todos los ficheros.
def buscarOCrearFicheroHashes(rutaCarpeta):
  hids_hash_database = SortedDict()
  rutaPrograma = os.getcwd()
  rutaFicheroHashes = rutaPrograma+'/hashes.pickle'
  if os.path.exists(rutaFicheroHashes):
    deserializarDiccionarioHashes(rutaFicheroHashes, hids_hash_database)
    listaficherossha256(rutaCarpeta, hids_hash_database)
  else:
    listaficherossha256(rutaCarpeta, hids_hash_database)
    serializarDiccionarioHashes(rutaFicheroHashes, hids_hash_database)
  return hids_hash_database

#Comprueba la integridad de los ficheros
def comprobarintegridad(dir, sortedDict):
 numFicherosTotal = 0
 numFicherosCorrompidos = 0
 for key in sortedDict.keys():
  numFicherosTotal += 1
  if not os.path.exists(key):
    print("El fichero con ubicación "+ key+" ha sido eliminado")
  elif sortedDict.get(key) != hashficherosha256(key):
    numFicherosCorrompidos +=1
    print("El fichero con ubicación "+ key+" ha sido corrompido")
 return numFicherosTotal, numFicherosCorrompidos

def registroDiario(numFicherosTotal, numFicherosCorrompidos):
  rutaPrograma = os.getcwd()
  file = open(rutaPrograma+"/registroDiario.txt","a")
  now = datetime.now()
  porcentajeFicherosIntegros = ((numFicherosTotal - numFicherosCorrompidos)/(numFicherosTotal))*100
  file.write(str(now.day)+"/"+str(now.month)+"/"+str(now.year)+" "+str(now.hour)+":"+str(now.minute)+":"+str(now.second)+" "+str(porcentajeFicherosIntegros)+" % "+str(numFicherosCorrompidos)+" ficheros han sido corrompidos" + os.linesep)

def comprobarYRegistrarIntegridad():
  global ruta, diccionarioHashes
  numFicherosTotal, numFicherosCorrompidos = comprobarintegridad(ruta, diccionarioHashes)
  registroDiario(numFicherosTotal, numFicherosCorrompidos)

print("Escriba la ruta de la carpeta sobre la cual quiere comprobar diariamente la integridad.")
ruta = input()
print("Se va a comenzar a comprobar la integridad de los ficheros existentes en la ruta: "+ruta)
diccionarioHashes = buscarOCrearFicheroHashes(ruta)
print("Se han cargado los hashes de los ficheros existentes. Se comenzará con la comprobación continua de la integridad.")
schedule.every(10).seconds.do(comprobarYRegistrarIntegridad)

while True:
    schedule.run_pending()
    time.sleep(1)